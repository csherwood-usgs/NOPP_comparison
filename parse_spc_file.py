"""
This routine parses the ADCIRC/SWAN ascii .spc files and computes
bulk parameters and fluxes, resulting in time series of parameters.

Chris Sherwood, USGS
Lots of help from Chat-GPT 5
"""

import re
import numpy as np
import xarray as xr
from datetime import datetime

import wave_stats

print('parse_spc_file.py loaded.')

# -------------------- helpers --------------------

def _next_nonempty(lines, j):
    n = len(lines)
    while j < n and not lines[j].strip():
        j += 1
    return j

def _read_block_floats(lines, j, nvals):
    """Read floats across as many lines as needed until nvals are collected."""
    vals = []
    n = len(lines)
    k = j
    while len(vals) < nvals and k < n:
        ln = lines[k].strip()
        if ln:
            vals.extend([float(t) for t in ln.split()])
        k += 1
    if len(vals) < nvals:
        raise ValueError("Unexpected EOF while reading numeric block.")
    return np.array(vals[:nvals], float), k

def _time_line_to_npdt(ln: str):
    """
    Parse lines like:
        20240925.000000                         date and time
    Returns np.datetime64 or None if not a time line.
    """
    if "date and time" not in ln.lower():
        return None
    tok = ln.split()[0]
    if "." not in tok:
        return None
    ymd, hms = tok.split(".")
    if len(hms) == 4:   # allow YYYYMMDD.HHMM
        hms += "00"
    dt = datetime.strptime(ymd + hms, "%Y%m%d%H%M%S")
    return np.datetime64(dt)

# -------------------- main parser --------------------

def read_swan_spec(path, h=30., normx=0.7071, normy=0.7071 ):
    """
    Read a SWAN ASCII .spec file (variant with single QUANT header, then repeated
    'date and time' blocks with optional FACTOR and NF×ND table).

    Input:
        path - path to .spc file
        h - local water depth [m]
        normx, normy = unit vectors toward shoreward direction, geographic convention []

    Returns
    -------
    xr.Dataset with:
      S2d(time, freq, dir) : 2-D variance density (units from file, e.g. m2/Hz/degr)
      Ef(time, freq)       : direction-integrated spectrum (m^2/Hz)
      Dth(time, dir)       : frequency-integrated directional energy (m^2 per rad)
      m0(time)             : zeroth moment (m^2)
      Hs(time)             : significant wave height (m)
      other stuff


    This was mostly generated by ChatGPT 5, which returned various ways to apply my functions
    to the datasets and label the attributes.
    """
    # constants
    rho = 1025.0
    g   = 9.81

    # Read the datafile into memeory
    with open(path, "r", encoding="utf-8", errors="ignore") as f:
        lines = [ln.rstrip("\n") for ln in f]

    n = len(lines)

    # Read AFREQ/freq and CDIR/dir (constant over time)
    NF = None
    ND = None
    freq = None
    direc = None

    i = 0
    while i < n:
        u = lines[i].strip().upper()

        # Absolute frequencies header; NF on next non-empty line; then NF floats
        if u.startswith(("AFREQ", "FREQ", "RFREQ")):
            i = _next_nonempty(lines, i + 1)
            m = re.match(r"^\s*(\d+)", lines[i])
            if not m:
                raise ValueError("Could not parse NFREQ after AFREQ/FREQ.")
            NF = int(m.group(1))
            freq, i = _read_block_floats(lines, i + 1, NF)
            continue

        # Direction header; ND on next non-empty line; then ND floats
        if u.startswith(("CDIR", "DIR", "CGRID")):
            i = _next_nonempty(lines, i + 1)
            m = re.match(r"^\s*(\d+)", lines[i])
            if not m:
                raise ValueError("Could not parse NDIR after CDIR/DIR.")
            ND = int(m.group(1))
            direc, i = _read_block_floats(lines, i + 1, ND)
            continue

        i += 1

    if NF is None or ND is None:
        raise ValueError("Missing NFREQ or NDIR in header.")
    freq = np.asarray(freq, float)
    direc = np.asarray(direc, float)

    # Pass 2: parse QUANT once, then loop over all times
    # Find QUANT
    i = 0
    while i < n and lines[i].strip().upper() != "QUANT":
        i += 1
    if i >= n:
        raise ValueError("QUANT block not found in file.")

    i += 1                           # move to "<NQ> number of quantities in table"
    i = _next_nonempty(lines, i)
    m = re.match(r"^\s*(\d+)", lines[i])
    NQ = int(m.group(1)) if m else 1
    i += 1                           # quantity name line
    qname = lines[i].strip().split()[0] if i < n else "VaDens"
    i += 1                           # unit string line
    units_2d = lines[i].strip().split()[0] if i < n else "m2/Hz/degr"
    i += 1                           # exception value line
    exc_value = None
    try:
        exc_value = float(lines[i].strip().split()[0])
    except Exception:
        exc_value = None
    i += 1

    # Loop over each time block
    times = []
    spectra = []

    while i < n:
        # seek next 'date and time' line
        tstamp = None
        while i < n and tstamp is None:
            tstamp = _time_line_to_npdt(lines[i].strip())
            i += 1
        if tstamp is None:
            break  # no more times
        times.append(tstamp)

        # optional FACTOR
        i = _next_nonempty(lines, i)
        factor = 1.0
        if i < n and lines[i].strip().upper().startswith("FACTOR"):
            i += 1
            i = _next_nonempty(lines, i)
            try:
                factor = float(lines[i].strip().split()[0])
            except Exception:
                factor = 1.0
            i += 1

        # read NF*ND numbers (often integers), then scale by factor
        nvals = int(NF * ND)
        vals, i = _read_block_floats(lines, i, nvals)
        S2 = (factor * vals).reshape(int(NF), int(ND))

        # skip additional quantities if NQ>1
        for _ in range(1, NQ):
            _, i = _read_block_floats(lines, i, nvals)

        # apply exception -> NaN
        if exc_value is not None:
            S2 = np.where(np.isclose(S2, exc_value, atol=0), np.nan, S2)

        spectra.append(S2)

    if not spectra:
        raise ValueError("No spectra blocks found after QUANT/time parsing.")

    time = np.array(times, dtype="datetime64[ns]")
    S2d = np.stack(spectra, axis=0).astype("float32")  # (time, NF, ND)

    ds = xr.Dataset(
        data_vars=dict(
            S2d=(("time", "freq", "dir"), S2d),
        ),
        coords=dict(
            time=time, freq=freq, dir=direc
        ),
        attrs=dict(
            source="SWAN .spec reader (QUANT once, repeated date-and-time blocks; FACTOR-scaled)",
            units_S2d=units_2d,  # e.g., 'm2/Hz/degr'
            quantity=qname
        )
    )

    # Angle convertsion boolean
    units = (units_2d or "").lower()
    per_degree = ("/deg" in units) or ("/degr" in units) # boolean: True if directional units are degrees

    # Derived values: m0, Hm0, m1, Tm01, Tm02
    if per_degree:
        # Convert deg bins to radians for integration
        ds["Ef"]  = (ds.S2d * np.deg2rad(1.0)).integrate("dir").astype("float32")  # m^2/Hz
        ds["Dth"] = (ds.S2d * np.deg2rad(1.0)).integrate("freq").astype("float32") # m^2 (per rad)
    else:
        ds["Ef"]  = ds.S2d.integrate("dir").astype("float32")
        ds["Dth"] = ds.S2d.integrate("freq").astype("float32")

    ds["m0"] = ds["Ef"].integrate("freq").astype("float32")
    ds["Hm0"] = (4.0 * np.sqrt(ds["m0"])).astype("float32")                            # m^2
    ds["m1"] = (ds['Ef'] * ds['freq']).integrate('freq')               # m^2
    ds["Tm01"] = (ds["m0"] / xr.where(ds['m1'] != 0, ds['m1'], np.nan)).astype('float32')
    ds["Tm01"].attrs.update(units='s', long_name='Energy mean period m0/m1')
    ds['m2'] = (ds['Ef'] * ds['freq']**2).integrate('freq')
    ds['Tm02'] = np.sqrt(ds['m0']/xr.where(ds['m2']!=0, ds['m2'] ,np.nan))

    # Angular frequency ω = 2πf   (freq in Hz)
    ds['omega'] = 2.0*np.pi*ds['freq']
    ds['omega'].attrs['long_name'] = 'angular frequency'
    ds['omega'].attrs['units'] = 'rad s^-1'
    
    # kh, cp, cg using my numpy routines (may not be vectorized)
    ds['kh'] = calc_kh( ds['omega'], h )
    ds['kh'].attrs.update(units='non-dimensional', long_name='k*h')
    
    ds['cp'], ds['cg'] = calc_cp_cg( ds['omega'], h )
    ds['cp'].attrs.update(units='m s^-1', long_name='phase velocity')
    ds['cg'].attrs.update(units='m s^-1', long_name='group velocity')
    
    # 2-D energy flux density:  (1/8)*rho*g*S2d * cg
    #    Dimensions: S2d(time,freq,dir), cg(freq) -> broadcast to (time,freq,dir)
    Eflux_2d = (rho*g/8.0) * ds['S2d'] * ds['cg']
    Eflux_2d.name = 'Eflux_2d'
    units_s2d = (ds.attrs.get('units_S2d') or '').lower()
    if per_degree:
        Eflux_2d.attrs['units'] = 'W m^-1 Hz^-1 deg^-1'
    else:
        # assume per-radian if not per-degree
        Eflux_2d.attrs['units'] = 'W m^-1 Hz^-1 rad^-1'
    Eflux_2d.attrs['long_name'] = '2-D wave energy flux density (per freq, per dir)'
    ds['Eflux_2d'] = Eflux_2d
    
    # Integrals of Eflux_2d
    #    → along-direction power spectrum P(f) [W/m/Hz]
    if per_degree:
        # convert per-degree to per-radian during integration
        ds['Eflux_f'] = (ds['Eflux_2d'] * np.deg2rad(1.0)).integrate('dir')
    else:
        ds['Eflux_f'] = ds['Eflux_2d'].integrate('dir')
    ds['Eflux_f'].attrs.update(units='W m^-1 Hz^-1', long_name='direction-integrated wave power spectrum')
    
    #    → along-frequency directional power P(θ) [W/m/rad] (or W/m/deg if you keep per-degree)
    ds['Eflux_dir'] = ds['Eflux_2d'].integrate('freq')
    if per_degree:
        ds['Eflux_dir'].attrs['units'] = 'W m^-1 deg^-1'
    else:
        ds['Eflux_dir'].attrs['units'] = 'W m^-1 rad^-1'
    ds['Eflux_dir'].attrs['long_name'] = 'frequency-integrated wave power by direction'
    
    #    → total wave power per unit crest length [W/m]
    if per_degree:
        total_power = (ds['Eflux_dir'] * np.deg2rad(1.0)).integrate('dir')
    else:
        total_power = ds['Eflux_dir'].integrate('dir')
    total_power = total_power.rename('Eflux_total')
    total_power.attrs.update(units='W m^-1', long_name='total wave power per unit crest length')
    ds['Eflux_total'] = total_power

    dtheta_factor = np.deg2rad(1.0) if per_degree else 1.0    
    # Unit vectors for each directional bin (CDIR in degrees, CCW from +x=east)
    theta = np.deg2rad(ds['dir'])
    ux = xr.DataArray(np.cos(theta), dims=['dir'], coords={'dir': ds['dir']})
    uy = xr.DataArray(np.sin(theta), dims=['dir'], coords={'dir': ds['dir']})
    
    W = ds['Eflux_2d']  # (time,freq,dir) weights in W/m/Hz/deg (or per-rad)
    
    # Flux-weighted vector sums (keep 'time'; integrate over freq & dir)
    Wx = (W * ux * dtheta_factor).integrate('dir').integrate('freq')   # (time,)
    Wy = (W * uy * dtheta_factor).integrate('dir').integrate('freq')   # (time,)
    Wsum = (W * dtheta_factor).integrate('dir').integrate('freq')      # (time,)
    
    # Mean direction θ_bar and resultant length R
    theta_bar = xr.apply_ufunc(np.arctan2, Wy, Wx)                     # radians
    theta_bar = (theta_bar % (2*np.pi)).astype('float32')
    R = (np.hypot(Wx, Wy) / xr.where(Wsum != 0, Wsum, np.nan)).astype('float32')
    
    ds['Dir_flux_mean'] = xr.DataArray(np.rad2deg(theta_bar), dims=['time'], coords={'time': ds['time']})
    ds['Dir_flux_mean'].attrs.update(units='deg', long_name='Energy-flux-weighted mean direction (going-to)')
    ds['Dir_flux_R'] = R
    ds['Dir_flux_R'].attrs.update(units='1', long_name='Resultant length of flux-weighted circular mean')

    # Shoreward flux
    
    # Unit vector of each directional bin.
    # For SWAN "CDIR spectral Cartesian directions in degr", angles are in degrees CCW from +x (east).
    # If your directions are "coming from" instead of "going to", flip sign on ux,uy (see note below).
    th = np.deg2rad(ds['dir'])
    ux = xr.DataArray(np.cos(th), coords={'dir': ds['dir']}, dims=['dir'])
    uy = xr.DataArray(np.sin(th), coords={'dir': ds['dir']}, dims=['dir'])
    
    # Projection factor p(θ) = n · u(θ)
    p = normx * ux + normy * uy  # dims: ('dir',)
    
    # Signed shoreward component of the 2-D flux
    EfluxS_2d = ds['Eflux_2d'] * p  # dims: (time,freq,dir)
    EfluxS_2d = EfluxS_2d.rename('EfluxS_2d')
    EfluxS_2d.attrs.update(
        long_name='Shoreward component of 2-D wave energy flux density',
        units=ds['Eflux_2d'].attrs.get('units', 'W m^-1 Hz^-1 deg^-1')
    )
    ds['EfluxS_2d'] = EfluxS_2d
    
    # Keep only shoreward (no offshore contribution)
    ds['EfluxS_2d_pos'] = ds['EfluxS_2d'].clip(min=0)
    ds['EfluxS_2d_pos'].attrs.update(
        long_name='Shoreward-only component (negative/offshore set to 0)',
        units=EfluxS_2d.attrs['units']
    )
    
    # Direction-integrated shoreward power spectrum P_s(f) [W/m/Hz]
    if per_degree:
        ds['EfluxS_f'] = (ds['EfluxS_2d'] * np.deg2rad(1.0)).integrate('dir')
    else:
        ds['EfluxS_f'] = ds['EfluxS_2d'].integrate('dir')
    ds['EfluxS_f'].attrs.update(units='W m^-1 Hz^-1', long_name='Direction-integrated shoreward power spectrum')
    
    # Frequency-integrated shoreward power by direction P_s(θ)
    ds['EfluxS_dir'] = ds['EfluxS_2d'].integrate('freq')
    ds['EfluxS_dir'].attrs.update(
        units=('W m^-1 deg^-1' if per_degree else 'W m^-1 rad^-1'),
        long_name='Frequency-integrated shoreward power by direction'
    )
    
    # Total shoreward wave power per unit crest length [W/m]
    if per_degree:
        ds['EfluxS_total'] = (ds['EfluxS_dir'] * np.deg2rad(1.0)).integrate('dir')
    else:
        ds['EfluxS_total'] = ds['EfluxS_dir'].integrate('dir')
    ds['EfluxS_total'].attrs.update(units='W m^-1', long_name='Total shoreward wave power (per unit crest length)')
    

    return ds
